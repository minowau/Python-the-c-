# Bytecode Generator Module

# This module will handle the generation of bytecode from the AST.

import os

class BytecodeGenerator:
    def __init__(self):
        self.audit_file_path = os.path.join(os.path.dirname(__file__), '..', '..', '..', 'audit_log.txt')

    def generate(self, ast):
        """Generate bytecode from the given AST."""
        bytecode = []
        self._walk_ast(ast, bytecode)
        self._optimize_bytecode(bytecode)
        self._log_update("Generated bytecode")
        return bytecode

    def _walk_ast(self, node, bytecode):
        """Recursively walk the AST and generate bytecode instructions."""
        node_type = node.get('type')
        if node_type == 'Program':
            for stmt in node.get('body', []):
                self._walk_ast(stmt, bytecode)
        elif node_type == 'NumberLiteral':
            bytecode.append(('PUSH_CONST', node['value']))
        elif node_type == 'StringLiteral':
            bytecode.append(('PUSH_CONST', node['value']))
        elif node_type == 'Identifier':
            bytecode.append(('LOAD_VAR', node['name']))
        elif node_type == 'Assignment':
            self._walk_ast(node['value'], bytecode)
            bytecode.append(('STORE_VAR', node['target']['name']))
        elif node_type == 'BinaryExpression':
            self._walk_ast(node['left'], bytecode)
            self._walk_ast(node['right'], bytecode)
            bytecode.append(('BINARY_OP', node['operator']))
        elif node_type == 'PrintStatement':
            self._walk_ast(node['argument'], bytecode)
            bytecode.append(('PRINT',))
        elif node_type == 'IfStatement':
            self._walk_ast(node['test'], bytecode)
            jump_index = len(bytecode)
            bytecode.append(('JUMP_IF_FALSE', None))
            for stmt in node.get('consequent', []):
                self._walk_ast(stmt, bytecode)
            if node.get('alternate'):
                jump_end = len(bytecode)
                bytecode.append(('JUMP', None))
                bytecode[jump_index] = ('JUMP_IF_FALSE', len(bytecode))
                for stmt in node['alternate']:
                    self._walk_ast(stmt, bytecode)
                bytecode[jump_end] = ('JUMP', len(bytecode))
            else:
                bytecode[jump_index] = ('JUMP_IF_FALSE', len(bytecode))
        elif node_type == 'WhileStatement':
            loop_start = len(bytecode)
            self._walk_ast(node['test'], bytecode)
            jump_index = len(bytecode)
            bytecode.append(('JUMP_IF_FALSE', None))
            for stmt in node.get('body', []):
                self._walk_ast(stmt, bytecode)
            bytecode.append(('JUMP', loop_start))
            bytecode[jump_index] = ('JUMP_IF_FALSE', len(bytecode))
        elif node_type == 'FunctionCall':
            for arg in node.get('arguments', []):
                self._walk_ast(arg, bytecode)
            bytecode.append(('CALL_FUNCTION', node['name'], len(node['arguments'])))
        # Extend with more AST node types as needed

    def _optimize_bytecode(self, bytecode):
        """Apply optimization passes to the generated bytecode."""
        self._constant_folding(bytecode)
        self._dead_code_elimination(bytecode)

    def _constant_folding(self, bytecode):
        """Perform constant folding optimization."""
        i = 0
        while i < len(bytecode) - 2:
            if bytecode[i][0] == 'PUSH_CONST' and bytecode[i+1][0] == 'PUSH_CONST' and bytecode[i+2][0] == 'BINARY_OP':
                left = bytecode[i][1]
                right = bytecode[i+1][1]
                op = bytecode[i+2][1]
                try:
                    if op == '+':
                        result = left + right
                    elif op == '-':
                        result = left - right
                    elif op == '*':
                        result = left * right
                    elif op == '/':
                        result = left / right
                    bytecode[i] = ('PUSH_CONST', result)
                    del bytecode[i+1:i+3]
                except (TypeError, ZeroDivisionError):
                    i += 1
            else:
                i += 1

    def _dead_code_elimination(self, bytecode):
        """Remove dead code that has no effect on program execution."""
        i = 0
        while i < len(bytecode):
            if bytecode[i][0] == 'JUMP_IF_FALSE' and bytecode[i][1] == i+1:
                del bytecode[i]
            else:
                i += 1

    def _log_update(self, message):
        """Log update to the audit file."""
        with open(self.audit_file_path, 'a') as audit_file:
            audit_file.write(f"{message}\n")